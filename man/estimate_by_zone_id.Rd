% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_by_zone_id.R
\name{estimate_by_zone_id}
\alias{estimate_by_zone_id}
\title{Estimate ACS Variables by Zone ID Using Area-Weighted Averages}
\usage{
estimate_by_zone_id(
  variables,
  zone_shapes,
  zone_id_col = "LocationId",
  year = 2020,
  state = "NY",
  county = c("New York", "Kings", "Queens"),
  survey = "acs5",
  remove_na = TRUE
)
}
\arguments{
\item{variables}{Character vector. ACS variable codes to retrieve (e.g., "B08013_001").}

\item{zone_shapes}{sf object. Spatial polygons representing the zones of interest.
Must contain a unique identifier column specified by \code{zone_id_col}.}

\item{zone_id_col}{Character. Name of the column in \code{zone_shapes} that contains
unique zone identifiers. Default is "OBJECTID".}

\item{year}{Numeric. Year for ACS data retrieval. Default is 2020.}

\item{state}{Character. State abbreviation for ACS data retrieval. Default is "NY".}

\item{county}{Character vector. County names for ACS data retrieval.
Default is c("New York", "Kings", "Queens") for Manhattan, Brooklyn, and Queens.}

\item{survey}{Character. ACS survey type. Default is "acs5" for 5-year estimates.}

\item{remove_na}{Logical. Whether to remove tracts with missing estimates. Default is TRUE.}

\item{cache_dir}{Character. Optional directory path for caching intermediate results.
If NULL, no caching is performed.}
}
\value{
A data.table with zone identifiers and area-weighted estimates for each variable.
The output is in wide format with one column per variable.
}
\description{
This function retrieves American Community Survey (ACS) data for specified variables
and geographic areas, then spatially joins the data with custom zone shapes to
calculate area-weighted estimates for each zone. Variables are processed in parallel
for improved performance when multiple variables are requested.
}
\details{
The function performs the following steps:
\enumerate{
\item Processes each variable in parallel using \code{future.apply::future_lapply()}
\item For each variable: retrieves ACS tract-level data with geometry
\item Transforms coordinate reference system to match the zone shapes
\item Performs spatial joins to identify tracts within and overlapping zones
\item Clips overlapping tracts to zone boundaries using spatial intersection
\item Calculates area-weighted averages for each zone using tract areas as weights
\item Combines results from all variables in wide format with one row per zone
}
}
\note{
\itemize{
\item Requires packages: tidycensus, sf, data.table, future.apply
\item Census API key must be configured for tidycensus
\item Zone shapes must have a valid CRS with EPSG code
\item Function assumes tract-level geography for ACS data
\item Uses parallel processing for multiple variables via future.apply
\item Set up parallel backend with future::plan() before calling function
}
}
\examples{
\dontrun{
# Set up parallel processing
library(future)
plan(multisession, workers = 4)

# Example zone shapes (replace with your actual data)
zones <- sf::st_read("path/to/zone_shapes.shp")

# Single variable
travel_time_estimates <- estimate_by_zone_id(
  variables = "B08013_001",
  zone_shapes = zones,
  year = 2020
)

# Multiple variables with parallel processing
transport_estimates <- estimate_by_zone_id(
  variables = c("B08013_001", "B08301_001", "B08301_010"),
  zone_shapes = zones,
  zone_id_col = "LocationID",
  year = 2020,
  cache_dir = "cache/"
)

# Clean up parallel backend
plan(sequential)
}

}
\seealso{
\code{\link[tidycensus]{get_acs}}, \code{\link[sf]{st_join}},
\code{\link[sf]{st_intersection}}, \code{\link[data.table]{dcast}},
\code{\link[future.apply]{future_lapply}}, \code{\link[future]{plan}}
}
