% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_join_geospatial_features.R
\name{step_join_geospatial_features}
\alias{step_join_geospatial_features}
\alias{step_join_geospatial_features_new}
\alias{tidy.step_join_geospatial_features}
\title{Join Geospatial Features to Recipe Data}
\usage{
step_join_geospatial_features(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  spatial_features,
  col_pattern = NULL,
  inputs = NULL,
  skip = FALSE,
  id = recipes::rand_id("join_geospatial_features")
)

step_join_geospatial_features_new(
  terms,
  role,
  trained,
  spatial_features,
  col_pattern,
  inputs,
  skip,
  id
)

\method{tidy}{step_join_geospatial_features}(x, ...)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence of
operations for this recipe.}

\item{...}{One or more selector functions to choose variables from the data
to use for joining. See \code{\link[recipes:selections]{recipes::selections()}} for more details.}

\item{role}{For model terms created by this step, what analysis role should
they be assigned? By default, the new columns created by this step from
the original variables will be assigned the same role as the original
column. If the original variable has role \code{NA}, then \code{predictor} is used.}

\item{trained}{A logical to indicate if the quantities for preprocessing
have been estimated.}

\item{spatial_features}{A data frame containing the geospatial features to
join with the recipe data. This should contain both spatial variables and
the joining columns.}

\item{col_pattern}{A character vector of prefixes to remove from selected
columns in the main data. For each prefix, the step will:
\itemize{
\item Identify main data columns starting with the prefix
\item Create a copy of \code{spatial_features} with all columns prefixed
\item Join using the prefixed columns
}
When \code{NULL}, a direct join is performed using selected columns.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked
by \code{\link[recipes:bake]{recipes::bake()}}? While all operations are baked when \code{\link[recipes:prep]{recipes::prep()}}
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using \code{skip = TRUE} as it may affect the computations for subsequent
operations.}

\item{id}{A character string that is unique to this step to identify it.}

\item{x}{A \code{step_join_geospatial_features} object.}
}
\value{
An updated version of \code{recipe} with the new step added to the
sequence of any existing operations.
}
\description{
\code{step_join_geospatial_features} creates a specification of a recipe step that
joins geospatial features to the data based on specified columns. This step
allows you to enrich your dataset with spatial information by joining on
matching geographical identifiers.
}
\details{
This step performs a join operation between the recipe data and provided
geospatial features. The join behavior depends on \code{col_pattern}:
\itemize{
\item When \code{col_pattern} is provided, the step processes each prefix by:
\enumerate{
\item Selecting main data columns starting with the prefix
\item Creating prefixed copies of spatial features
\item Performing joins using the prefixed columns
}
\item When \code{col_pattern} is \code{NULL}, a direct join is performed using the selected
columns without renaming
}
}
\section{Tidying}{

When you \code{\link[generics:tidy]{tidy()}} this step, a tibble is returned with
columns \code{terms}, \code{spatial_features}, and \code{id}:

\describe{
\item{terms}{character, the columns used for joining}
\item{spatial_features}{character, names of spatial feature columns added}
\item{id}{character, id of this step}
}

There is one row for each pair of (join column, spatial feature).
}

\section{Case weights}{

This step performs an inner join. The case weights are not modified by this
step and are assumed to be based on the original data structure.
}

\examples{
# Create sample data
main_data = data.frame(
  region_id = c("A", "B", "C"),
  value = c(10, 20, 30)
)

# Create spatial features
spatial_data = data.frame(
  region_id = c("A", "B", "C"),
  latitude = c(40.7, 34.1, 41.9),
  longitude = c(-74.0, -118.2, -87.6),
  population = c(1000, 2000, 1500)
)

# Adding geospatial features
recipes::recipe(value ~ ., data = main_data) |>
  step_join_geospatial_features(
    region_id,
    spatial_features = spatial_data
  ) |>
  recipes::prep() |>
  recipes::bake(new_data = NULL)


# Expanding data start and end region id
main_data_prefix = main_data
main_data_prefix$region_id = NULL
main_data_prefix$start_region_id = main_data$region_id
main_data_prefix$end_region_id = rev(main_data$region_id)

# Adding geospatial features
recipes::recipe(value ~ ., data = main_data_prefix) |>
  step_join_geospatial_features(
   ends_with("region_id"),
    spatial_features = spatial_data,
    col_pattern = c("start_", "end_")
  ) |>
  recipes::prep() |>
  recipes::bake(new_data = NULL)

}
