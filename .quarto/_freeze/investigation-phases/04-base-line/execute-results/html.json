{
  "hash": "dad04b0b73f24477f986640cc8711c5a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Defining Base Line\"\nparams:\n  UpdateSimulation: FALSE\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\nDefining the baseline based on this data is a challenge as the data doesn't have any *unique id* to make the estimation, but we can **run a simulation** to estimate its value with a confident interval.\n\n---\n\n## Defining Business Metric\n\nBased on the current information, we can say that our objective is to increase the **Daily Hourly Wage** received by each taxi driver defined by the following formula:\n\n$$\n\\text{Daily Hourly Wage} = \\frac{\\text{Total Earnings}}{\\text{Total Hours Worked}}\n$$\n\n\n## Simulation Assumptions\n\nThe simulation will be based on the following **assumptions** related to the taxi drivers:\n\n1.  They can start to work:\n\n    -   From any zone of Manhattan, Brooklyn or Queens (the more active ones)\n    -   From any month, weekday or hour.\n\n2.  The TLC license number (taxi company) needs to keep constant for all trips in workday.\n\n3.  Only wheelchair-accessible vehicles can accept trips with that request.\n\n4.  As we cannot estimate whether each zone have more active taxis than passengers we will assume that there is always more passengers than taxis and each taxi driver can **accept the first requested trip**.\n\n5.  The taxis will find trips based on their time waiting and will take the first trip in their valid radius:\n\n    -   0-1 Minute: Search within a 1-mile radius.\n\n    -   1-3 Minutes: Expand search to a 3-mile radius if no trip is found.\n\n    -   3-5 Minutes: Expand search to a 5-mile radius if still no trip is found.\n\n    -   Keep adding 2 miles every two minutes until finding a trip.\n\n6.  They have a 30 minutes break after 4 hours working once ending the current trip.\n\n7.  They will take their last trip after working 8 hours, without taking into consideration the 30 minutes break.\n\n\n## Running trips simulation\n\n1.  Loading the functions to use.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(lubridate)\nlibrary(infer)\nlibrary(DBI)\nlibrary(duckdb)\nlibrary(glue)\n\n## Custom functions\ndevtools::load_all()\n\noptions(datatable.print.nrows = 15)\n```\n:::\n\n\n\n\n2.  Creating folders to save data on disk.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!dir.exists(here(\"output\"))) dir.create(here(\"output\"))\nif(!dir.exists(here(\"output/take-trip-fst\"))) dir.create(here(\"output/take-trip-fst\"))\nif(!dir.exists(here(\"output/cache-data\"))) dir.create(here(\"output/cache-data\"))\n```\n:::\n\n\n\n\n3.  Creating a connection with DuckDB.\n\n``` r\ncon <- dbConnect(duckdb(), dbdir = here(\"output/my-db.duckdb\"))\n```\n\n4.  Importing the definition of each code zone.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZoneCodesRef <-\n  fread(here(\"raw-data/taxi_zone_lookup.csv\"),\n        colClasses = c(\"integer\",\n                       \"character\",\n                       \"character\",\n                       \"character\"))\n```\n:::\n\n\n\n\n5.  As most of the trips take place between **Manhattan**, **Brooklyn** and **Queens**, let's list all possible combinations of related locations to use it as filter later.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZoneCodesFilter <-\n  ZoneCodesRef[c(\"Manhattan\", \"Brooklyn\", \"Queens\"), \n               on = \"Borough\",\n               CJ(PULocationID = LocationID,\n                  DOLocationID = LocationID)]\n```\n:::\n\n\n\n\n5.  Selecting at random the first trip of each simulation. It's important to know that even after setting the seed 3518 **the sample is not reproducible**, so we need to save the on disk to keep using the same data.\n\n``` r\n# Addig ZoneCodesFilters to db\ndbWriteTable(con, \"ZoneCodesFilter\", ZoneCodesFilter)\n\n# Sampling 60 trips from db\nSimulationStartDayQuery <- \"\nSELECT t1.*\nFROM NycTrips t1\nINNER JOIN ZoneCodesFilter t2\n  ON t1.PULocationID = t2.PULocationID AND\n     t1.DOLocationID = t2.DOLocationID\nWHERE t1.year = 2023\nUSING SAMPLE reservoir(60 ROWS) REPEATABLE (3518);\n\"\nSimulationStartDay <- dbGetQuery(con, SimulationStartDayQuery)\nsetDT(SimulationStartDay)\n\n# Saving results\nfst::write_fst(SimulationStartDay, here(\"output/cache-data/SimulationStartDay.fst\"))\n\npillar::glimpse(SimulationStartDay)\n```\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 60\nColumns: 28\n$ trip_id              <dbl> 231484989, 438922689, 295887990, 362960205, 34445…\n$ hvfhs_license_num    <chr> \"HV0003\", \"HV0005\", \"HV0003\", \"HV0003\", \"HV0003\",…\n$ dispatching_base_num <chr> \"B03404\", \"B03406\", \"B03404\", \"B03404\", \"B03404\",…\n$ originating_base_num <chr> \"B03404\", NA, \"B03404\", \"B03404\", \"B03404\", \"B034…\n$ request_datetime     <dttm> 2023-02-01 23:56:37, 2023-12-21 15:37:47, 2023-0…\n$ on_scene_datetime    <dttm> 2023-02-01 23:59:42, NA, 2023-05-12 19:36:15, 20…\n$ pickup_datetime      <dttm> 2023-02-02 00:00:50, 2023-12-21 15:43:09, 2023-0…\n$ dropoff_datetime     <dttm> 2023-02-02 00:08:37, 2023-12-21 16:03:57, 2023-0…\n$ PULocationID         <dbl> 130, 50, 191, 132, 74, 232, 145, 142, 181, 137, 2…\n$ DOLocationID         <dbl> 121, 229, 101, 255, 116, 228, 157, 161, 112, 225,…\n$ trip_miles           <dbl> 1.520, 2.257, 4.440, 15.720, 2.340, 8.180, 3.060,…\n$ trip_time            <dbl> 467, 1248, 865, 3044, 1353, 1711, 1448, 455, 1934…\n$ base_passenger_fare  <dbl> 9.74, 20.79, 16.74, 46.71, 14.28, 32.48, 18.82, 1…\n$ tolls                <dbl> 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0…\n$ bcf                  <dbl> 0.29, 0.57, 0.50, 1.35, 0.39, 0.97, 0.52, 0.32, 0…\n$ sales_tax            <dbl> 0.86, 1.84, 1.49, 4.37, 1.27, 2.88, 1.67, 1.03, 2…\n$ congestion_surcharge <dbl> 0.00, 2.75, 0.00, 0.00, 0.00, 0.75, 0.00, 2.75, 0…\n$ airport_fee          <dbl> 0.0, 0.0, 0.0, 2.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,…\n$ tips                 <dbl> 0.00, 0.00, 0.00, 5.49, 0.00, 0.00, 0.00, 0.00, 0…\n$ driver_pay           <dbl> 6.65, 14.83, 14.03, 49.77, 15.79, 26.84, 19.54, 5…\n$ shared_request_flag  <chr> \"N\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ shared_match_flag    <chr> \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\",…\n$ access_a_ride_flag   <chr> \" \", \"N\", \" \", \" \", \" \", \" \", \" \", \"N\", \"N\", \"N\",…\n$ wav_request_flag     <chr> \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\",…\n$ wav_match_flag       <chr> \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\",…\n$ month                <chr> \"02\", \"12\", \"05\", \"08\", \"07\", \"06\", \"10\", \"08\", \"…\n$ year                 <dbl> 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2023, 2…\n$ performance_per_hour <dbl> 51.26338, 42.77885, 58.39075, 65.35348, 42.01330,…\n```\n\n\n:::\n:::\n\n\n\n\nWe can also confirm that the sample satisfy the initial restrictions:\n\n-   All trips are from 2023.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSimulationStartDay[, .N, year]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    year     N\n   <num> <int>\n1:  2023    60\n```\n\n\n:::\n:::\n\n\n\n\n-   The trips begin on the expected boroughs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZoneCodesRef[SimulationStartDay, \n             on = c(\"LocationID\" = \"PULocationID\"),\n             .N,\n             by = \"Borough\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Borough     N\n      <char> <int>\n1:    Queens    15\n2: Manhattan    25\n3:  Brooklyn    20\n```\n\n\n:::\n:::\n\n\n\n\n-   The trips end on the expected boroughs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZoneCodesRef[SimulationStartDay, \n             on = c(\"LocationID\" = \"DOLocationID\"),\n             .N,\n             by = \"Borough\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Borough     N\n      <char> <int>\n1:    Queens    18\n2: Manhattan    20\n3:  Brooklyn    22\n```\n\n\n:::\n:::\n\n\n\n\nNow we can conclude that the initial data **satisfy the assumption 1**.\n\n6.  Calculating the mean distance present from one location to other if it has **fewer than 7 miles**.\n\n``` r\nMeanDistanceQuery <- \"\nCREATE TABLE PointMeanDistance AS\n\n-- Selecting all avaiable from trips that don't start and end at same point\nWITH ListOfPoints AS (\n  SELECT \n    t1.PULocationID,\n    t1.DOLocationID,\n    AVG(t1.trip_miles) AS trip_miles_mean\n  FROM \n    NycTrips t1\n  INNER JOIN\n    ZoneCodesFilter t2\n    ON t1.PULocationID = t2.PULocationID AND\n       t1.DOLocationID = t2.DOLocationID\n  WHERE\n    t1.PULocationID <> t1.DOLocationID AND\n    t1.year = 2023\n  GROUP BY \n    t1.PULocationID, \n    t1.DOLocationID\n  HAVING \n    AVG(t1.trip_miles) <= 7\n),\n\n-- Defining all available distances\nListOfPointsComplete AS (\n  SELECT\n    PULocationID,\n    DOLocationID,\n    trip_miles_mean\n  FROM ListOfPoints\n  UNION ALL\n  SELECT\n    DOLocationID AS PULocationID,\n    PULocationID AS DOLocationID,\n    trip_miles_mean\n  FROM ListOfPoints\n),\nNumeredRows AS (\n  SELECT\n    PULocationID,\n    DOLocationID,\n    trip_miles_mean,\n    row_number() OVER (PARTITION BY PULocationID, DOLocationID) AS n_row\n  FROM ListOfPointsComplete\n)\n\n-- Selecting the first combination of distances\nSELECT \n  PULocationID,\n  DOLocationID,\n  trip_miles_mean\nFROM NumeredRows\nWHERE n_row = 1\nORDER BY PULocationID, trip_miles_mean;\n\"\n\n# Saving table on DB for simulation\ndbExecute(con, MeanDistanceQuery)\n\n# Saving the table as a file\nPointMeanDistance <- dbGetQuery(con, \"SELECT * FROM PointMeanDistance\")\nfst::write_fst(PointMeanDistance,here(\"output/cache-data/PointMeanDistance.fst\"))\n```\n\n7.  Running the simulation.\n\n``` r\nSimulationHourlyWage <- simulate_trips(con, SimulationStartDay)\n```\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n8.  Disconnecting from DB.\n\n``` r\ndbDisconnect(con, shutdown = TRUE)\n```\n\n9.  Showing simulation results.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDailyHourlyWage <-\n  SimulationHourlyWage[, .(`Daily Hourly Wage` = \n                             sum(sim_driver_pay + sim_tips) /\n                             as.double(difftime(max(sim_dropoff_datetime), \n                                                min(sim_request_datetime),\n                                                units = \"hours\"))),\n                       by = \"simulation_id\"]\n\n\nDailyHourlyWage |>\n  ggplot()+\n  geom_histogram(aes(`Daily Hourly Wage`),\n                 bins = 10) +\n  scale_x_continuous(breaks = breaks_width(10)) +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](04-base-line_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n## Defining a Condifence Interval\n\nAfter simulating 60 days, we can use **bootstrap** to infer the distribution of the mean **Daily Hourly Wage** for any day in the year by following the next steps.\n\n1.  Resample with replacement a new 60 days hourly wage 3,000 times and calculate the mean of each resample.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1586)\n\nBootstrapHourlyWage <-\n  specify(DailyHourlyWage,\n          `Daily Hourly Wage` ~ NULL) |>\n  generate(reps = 3000, type = \"bootstrap\") |>\n  calculate(stat = \"mean\")\n\nBootstrapHourlyWage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nResponse: Daily Hourly Wage (numeric)\n# A tibble: 3,000 × 2\n   replicate  stat\n       <int> <dbl>\n 1         1  55.1\n 2         2  53.5\n 3         3  53.2\n 4         4  52.8\n 5         5  54.2\n 6         6  53.1\n 7         7  54.3\n 8         8  53.4\n 9         9  54.3\n10        10  52.6\n# ℹ 2,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\n2.  Compute the 95% confident interval.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBootstrapInterval <- \n  get_ci(BootstrapHourlyWage, \n         level = 0.95,\n         type = \"percentile\")\n\nBootstrapInterval\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  lower_ci upper_ci\n     <dbl>    <dbl>\n1     50.5     57.1\n```\n\n\n:::\n:::\n\n\n\n\n3.  Visualize the estimated distribution.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvisualize(BootstrapHourlyWage)+\n  shade_ci(endpoints = BootstrapInterval,\n           color = \"#2c77BF\",\n           fill = \"#2c77BF\")+\n  annotate(geom = \"text\",\n           y = 400,\n           x = c(BootstrapInterval[1L][[1L]] - 0.4,\n                 BootstrapInterval[2L][[1L]] + 0.4),\n           label = unlist(BootstrapInterval) |> comma(accuracy = 0.01))+\n  labs(title = \"Mean Hourly Wage Distribution\",\n       y = \"Count\")+\n  theme_light()+\n  theme(panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank(),\n        plot.title = element_text(face = \"bold\"),\n        axis.title.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](04-base-line_files/figure-html/parsermd-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n## Business Case\n\nBased on the simulation's results we can confirm that the average earnings for a taxi driver per hour goes between 50.5 and 57.12, but that doesn't represent the highest values observed on the simulation.\n\nIf we can check the simulation results we can confirm that a 25% of the simulated days presented earnings over the 60 dollars per hour.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGoalRate <- \n  DailyHourlyWage$`Daily Hourly Wage` |>\n  quantile(probs = 0.75) |>\n  unname() |>\n  round(2)\n\nGoalRate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 60.46\n```\n\n\n:::\n:::\n\n\n\n\nIf we can apply a strategy that can move the `Daily Hourly Wage` to 60.46 dollars per hour, assuming the the taxi driver works 5 days every week for 8 hours, that would mean a increase of **$1,593.37 every month**.\n",
    "supporting": [
      "04-base-line_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}